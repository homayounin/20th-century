Here's the revised, step-by-step guide to complete Chapter 7 tasks in your Jupyter Notebook, including explanations and code:

Step 1: Install the Necessary Libraries
Ensure all required libraries are installed by running the following command:

bash
Copy code
pip install -r requirements.txt
This command should install:

pandas
networkx
matplotlib
pyvis
seaborn
python-igraph
leidenalg
Step 2: Import the Country Relationships CSV File
Start by importing libraries and loading the CSV file into a DataFrame.

python
Copy code
# Step 2: Import libraries and load the DataFrame
import pandas as pd
import networkx as nx
from pyvis.network import Network

# Load the CSV file into a DataFrame
relationships_df = pd.read_csv('country_relationships.csv')

# Display the first few rows to confirm successful import
relationships_df.head()
Step 3: Create a Network Object from the DataFrame
Convert the DataFrame into a NetworkX graph.

python
Copy code
# Step 3: Create a NetworkX graph object
G = nx.Graph()

# Add edges to the graph from the DataFrame
for index, row in relationships_df.iterrows():
    G.add_edge(row['Country1'], row['Country2'])

# Print basic graph info
print(nx.info(G))
Step 4: Create a Static Network Graph Using NetworkX
Visualize the static graph using matplotlib.

python
Copy code
# Step 4: Visualize the static network graph
import matplotlib.pyplot as plt

plt.figure(figsize=(12, 8))
nx.draw(G, with_labels=True, node_size=700, node_color='lightblue', font_size=10, font_weight='bold')
plt.title("Static Network Graph of Country Relationships")
plt.show()
Step 5: Create an Interactive Network Graph Using PyVis
Create an interactive graph with PyVis and save it as an HTML file.

python
Copy code
# Step 5: Create an interactive network graph with PyVis
net = Network(notebook=True, height="750px", width="100%", bgcolor="#222222", font_color="white")

# Load the NetworkX graph into PyVis
net.from_nx(G)

# Save the interactive graph as an HTML file
net.show('interactive_country_network.html')
Step 6: Apply the Leiden Algorithm for Community Detection
Install python-igraph and leidenalg if you haven't already:

bash
Copy code
pip install python-igraph leidenalg
Apply the Leiden algorithm:

python
Copy code
# Step 6: Apply the Leiden algorithm for community detection
import igraph as ig
import leidenalg

# Convert NetworkX graph to iGraph
igraph_g = ig.Graph.TupleList(G.edges(), directed=False)

# Apply Leiden algorithm for community detection
partition = leidenalg.find_partition(igraph_g, leidenalg.ModularityVertexPartition)

# Print partition information
print("Detected Communities:")
for i, community in enumerate(partition):
    print(f"Community {i}: {', '.join([igraph_g.vs[node]['name'] for node in community])}")
Step 7: Visualize Communities and Save as HTML
Use PyVis to create a community-based interactive graph.

python
Copy code
# Step 7: Visualize communities with PyVis
community_net = Network(notebook=True, height="750px", width="100%", bgcolor="#222222", font_color="white")

# Add nodes with colors for communities
colors = ['red', 'green', 'blue', 'yellow', 'purple', 'orange']
for i, community in enumerate(partition):
    for node in community:
        community_net.add_node(igraph_g.vs[node]['name'], color=colors[i % len(colors)])

# Add edges
for edge in G.edges():
    community_net.add_edge(edge[0], edge[1])

# Save the community graph as an HTML file
community_net.show('community_network.html')
Observations on Community Detection
The partition generated by the Leiden algorithm reveals distinct communities within the network.
The detected communities might align with historical, cultural, or economic relationships.
Step 8: Calculate and Visualize Centrality Measures
Calculate degree, closeness, and betweenness centrality:

python
Copy code
# Step 8: Centrality Measures
degree_centrality = nx.degree_centrality(G)
closeness_centrality = nx.closeness_centrality(G)
betweenness_centrality = nx.betweenness_centrality(G)

# Convert to DataFrame for visualization
centrality_df = pd.DataFrame({
    'Country': list(degree_centrality.keys()),
    'Degree Centrality': list(degree_centrality.values()),
    'Closeness Centrality': list(closeness_centrality.values()),
    'Betweenness Centrality': list(betweenness_centrality.values())
})

# Visualize centrality measures
import seaborn as sns

plt.figure(figsize=(14, 6))
sns.barplot(x='Country', y='Degree Centrality', data=centrality_df.sort_values(by='Degree Centrality', ascending=False))
plt.xticks(rotation=90)
plt.title("Degree Centrality of Countries")
plt.show()

plt.figure(figsize=(14, 6))
sns.barplot(x='Country', y='Closeness Centrality', data=centrality_df.sort_values(by='Closeness Centrality', ascending=False))
plt.xticks(rotation=90)
plt.title("Closeness Centrality of Countries")
plt.show()

plt.figure(figsize=(14, 6))
sns.barplot(x='Country', y='Betweenness Centrality', data=centrality_df.sort_values(by='Betweenness Centrality', ascending=False))
plt.xticks(rotation=90)
plt.title("Betweenness Centrality of Countries")
plt.show()
Centrality Observations
Degree Centrality: Identifies the most connected countries.
Closeness Centrality: Indicates countries that can reach others efficiently.
Betweenness Centrality: Highlights countries that act as bridges between different parts of the network.
Step 9: Save and Push Your Notebook
Once you're done, save your work and push it to your GitHub repository:

bash
Copy code
git add "chapter_7_analysis.ipynb"
git commit -m "Completed Chapter 7 network analysis with centrality measures"
git push origin main
This completes your work for Chapter 7. Let me know if yo